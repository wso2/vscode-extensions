/**
 * Copyright (c) 2025, WSO2 LLC. (https://www.wso2.com) All Rights Reserved.
 *
 * WSO2 LLC. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import * as crypto from 'crypto';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';
import { workspace } from 'vscode';
import { ProjectSource } from '@wso2/ballerina-core';

/**
 * Auto-generated files that should use content-based comparison instead of mtime
 */
const AUTO_GENERATED_FILES = [
    'Dependencies.toml',
    'Ballerina.toml'
];

/**
 * Directories containing auto-generated content
 */
const AUTO_GENERATED_DIRECTORIES = [
    'target',
    '.ballerina'
];

/**
 * Information about a file modification
 */
export interface FileModificationInfo {
    /** Relative path to the file */
    filePath: string;
    /** Type of modification: modified, new, or deleted */
    type: 'modified' | 'new' | 'deleted';
}

/**
 * Result of getTempProject operation
 */
export interface TempProjectResult {
    /** Path to the temporary project directory */
    path: string;
    /** List of file modifications detected since last session */
    modifications: FileModificationInfo[];
    /** Whether this is a newly created temp project */
    isNew: boolean;
}

/**
 * Generates a hash from the workspace path
 * @returns SHA-256 hash of the workspace path
 */
function generateProjectHash(): string {
    if (!workspace.workspaceFolders || workspace.workspaceFolders.length === 0) {
        throw new Error('No workspace folder found');
    }

    const workspacePath = workspace.workspaceFolders[0].uri.fsPath;
    const hash = crypto.createHash('sha256');
    hash.update(workspacePath);
    return hash.digest('hex');
}

/**
 * Computes MD5 hash of file content
 * @param filePath Path to the file
 * @returns MD5 hash of the file content
 */
function getFileHash(filePath: string): string {
    const content = fs.readFileSync(filePath);
    const hash = crypto.createHash('md5');
    hash.update(content);
    return hash.digest('hex');
}

/**
 * Checks if a file is auto-generated and should use content-based comparison
 * @param relativePath Relative path to the file
 * @returns True if file is auto-generated
 */
function isAutoGeneratedFile(relativePath: string): boolean {
    const normalizedPath = relativePath.replace(/\\/g, '/');

    // Check for specific auto-generated files
    if (AUTO_GENERATED_FILES.includes(normalizedPath)) {
        return true;
    }

    // Check for directories that contain build artifacts or cache
    for (const dir of AUTO_GENERATED_DIRECTORIES) {
        if (normalizedPath.startsWith(dir + '/')) {
            return true;
        }
    }

    return false;
}

// TODO: Improve sync strategy and timing
// Current approach syncs all workspace files to temp on every session continuation.
// Consider:
// - More granular sync triggers (only sync when external changes detected)
// - Smarter sync timing (sync before AI operations, not during session start)
// - Bidirectional conflict detection (workspace vs temp changes)
// - Performance optimization for large projects

/**
 * Gets or creates a temporary project directory for AI operations.
 * Detects modifications since last session and syncs with workspace.
 *
 * @param projectSource The source project to copy
 * @param hasHistory Whether chat history exists (true = continuing session, false = new session)
 * @returns Result containing temp path, modifications, and isNew flag
 */
export async function getTempProject(projectSource: ProjectSource, hasHistory: boolean): Promise<TempProjectResult> {
    if (!workspace.workspaceFolders || workspace.workspaceFolders.length === 0) {
        throw new Error('No workspace folder found');
    }

    const projectRoot = workspace.workspaceFolders[0].uri.fsPath;
    const projectHash = generateProjectHash();
    const randomNum = Math.floor(Math.random() * 101);
    const tempDir = path.join(os.tmpdir(), `bal-proj-${projectHash}-${randomNum}`);

    // Check if temp project already exists
    if (fs.existsSync(tempDir)) {
        if (!hasHistory) {
            // No history means new session - delete old temp project and create fresh one
            console.log(`Deleting old temp project for new session: ${tempDir}`);
            fs.rmSync(tempDir, { recursive: true, force: true });
            // Fall through to create new temp directory
        } else {
            // Has history means continuing session - reuse and track modifications
            console.log(`Reusing existing temp project at: ${tempDir}`);
            // Update with latest workspace contents and detect modifications
            const modifications = await updateTempProject(tempDir, projectSource);
            return {
                path: tempDir,
                modifications,
                isNew: false
            };
        }
    }

    // Create temp directory
    fs.mkdirSync(tempDir, { recursive: true });

    // Copy entire workspace to temp directory
    fs.cpSync(projectRoot, tempDir, { recursive: true });

    console.log(`Created new temp project at: ${tempDir}`);
    return {
        path: tempDir,
        modifications: [],
        isNew: true
    };
}

/**
 * Updates an existing temporary project with the latest workspace contents
 * Performs a clean sync: copies changed files from workspace and removes files that don't exist in workspace
 *
 * @param tempPath Path to the temporary project
 * @param projectSource The source project with updated files
 * @returns Array of file modifications detected during sync
 */
export async function updateTempProject(tempPath: string, projectSource: ProjectSource): Promise<FileModificationInfo[]> {
    if (!fs.existsSync(tempPath)) {
        throw new Error(`Temp project does not exist at: ${tempPath}`);
    }

    if (!workspace.workspaceFolders || workspace.workspaceFolders.length === 0) {
        throw new Error('No workspace folder found');
    }

    const projectRoot = workspace.workspaceFolders[0].uri.fsPath;

    // Track all files in workspace for clean sync
    const workspaceFiles = new Set<string>();
    const modifications: FileModificationInfo[] = [];

    // Sync files from workspace to temp directory
    // Only copy files that have been modified (based on mtime)
    function syncDirectory(sourceDir: string, targetDir: string, basePath: string = '') {
        const entries = fs.readdirSync(sourceDir, { withFileTypes: true });

        for (const entry of entries) {
            const sourcePath = path.join(sourceDir, entry.name);
            const targetPath = path.join(targetDir, entry.name);
            const relativePath = path.join(basePath, entry.name);

            if (entry.isDirectory()) {
                // Track directory
                workspaceFiles.add(relativePath);

                // Create directory if it doesn't exist
                if (!fs.existsSync(targetPath)) {
                    fs.mkdirSync(targetPath, { recursive: true });
                }
                // Recursively sync subdirectories
                syncDirectory(sourcePath, targetPath, relativePath);
            } else if (entry.isFile()) {
                // Track file
                workspaceFiles.add(relativePath);

                // Check if file needs updating
                let shouldCopy = false;

                if (!fs.existsSync(targetPath)) {
                    // File doesn't exist in temp, copy it
                    shouldCopy = true;
                    modifications.push({
                        filePath: relativePath,
                        type: 'new'
                    });
                } else {
                    // Use different comparison strategies based on file type
                    if (isAutoGeneratedFile(relativePath)) {
                        // For auto-generated files, compare content hash
                        const sourceHash = getFileHash(sourcePath);
                        const targetHash = getFileHash(targetPath);

                        if (sourceHash !== targetHash) {
                            // Content actually changed
                            shouldCopy = true;
                            modifications.push({
                                filePath: relativePath,
                                type: 'modified'
                            });
                            console.log(`[TempProject] Content changed for auto-generated file: ${relativePath}`);
                        } else {
                            console.log(`[TempProject] Skipping auto-generated file with identical content: ${relativePath}`);
                        }
                    } else {
                        // For regular files, use mtime comparison (faster)
                        const sourceStats = fs.statSync(sourcePath);
                        const targetStats = fs.statSync(targetPath);

                        if (sourceStats.mtime > targetStats.mtime) {
                            // Source is newer, update it
                            shouldCopy = true;
                            modifications.push({
                                filePath: relativePath,
                                type: 'modified'
                            });
                        }
                    }
                }

                if (shouldCopy) {
                    fs.copyFileSync(sourcePath, targetPath);
                    console.log(`[TempProject] Updated: ${relativePath}`);
                }
            }
        }
    }

    // Clean up files in temp that don't exist in workspace
    function cleanupTempDirectory(targetDir: string, basePath: string = '') {
        if (!fs.existsSync(targetDir)) {
            return;
        }

        const entries = fs.readdirSync(targetDir, { withFileTypes: true });

        for (const entry of entries) {
            const targetPath = path.join(targetDir, entry.name);
            const relativePath = path.join(basePath, entry.name);

            if (entry.isDirectory()) {
                // Recursively clean subdirectories first
                cleanupTempDirectory(targetPath, relativePath);

                // If directory is not in workspace, remove it (will only succeed if empty)
                if (!workspaceFiles.has(relativePath)) {
                    try {
                        fs.rmdirSync(targetPath);
                        console.log(`[TempProject] Removed directory: ${relativePath}`);
                    } catch (error) {
                        // Directory not empty, skip
                    }
                }
            } else if (entry.isFile()) {
                // If file is not in workspace, remove it
                if (!workspaceFiles.has(relativePath)) {
                    fs.unlinkSync(targetPath);
                    modifications.push({
                        filePath: relativePath,
                        type: 'deleted'
                    });
                    console.log(`[TempProject] Removed file: ${relativePath}`);
                }
            }
        }
    }

    syncDirectory(projectRoot, tempPath);
    cleanupTempDirectory(tempPath);
    console.log(`Updated temp project at: ${tempPath}`);
    return modifications;
}

/**
 * Cleans up a temporary project directory
 *
 * @param tempPath Path to the temporary project to delete
 */
export function cleanupTempProject(tempPath: string): void {
    if (fs.existsSync(tempPath)) {
        try {
            fs.rmSync(tempPath, { recursive: true, force: true });
            console.log(`Cleaned up temp project at: ${tempPath}`);
        } catch (error) {
            console.error(`Failed to cleanup temp project at ${tempPath}:`, error);
        }
    }
}

/**
 * Gets the temporary project path for the current workspace without creating it
 * Useful for checking if a temp project exists
 *
 * @returns The expected path to the temporary project directory
 */
export function getTempProjectPath(): string {
    const projectHash = generateProjectHash();
    return path.join(os.tmpdir(), `bal-proj-${projectHash}`);
}
